package org.medale.exsiter;

/**
 * Assumes Unix paths, i.e. directories separated by /. Stores md5hash for a
 * given file at a file path (generated by find piped to md5sum command).
 */
public class FilePathChecksumTriple {

    protected static final int MD5_HASH_INDEX = 0;
    protected static final int FILE_NAME_AND_PATH_INDEX = 1;
    protected static final String DOUBLE_SPACE = "  ";

    protected static final int FILE_PATH_INDEX = 0;
    protected static final int FILE_NAME_INDEX = 1;
    protected static final String EMPTY_STRING = "";
    protected static final String FORWARD_SLASH = "/";

    private String md5Hash;
    private String filePath;
    private String fileName;

    public FilePathChecksumTriple(String md5Hash, String filePath,
            String fileName) {
        this.md5Hash = md5Hash;
        this.filePath = filePath;
        this.fileName = fileName;
    }

    public FilePathChecksumTriple(String md5Hash, String fileNameWithPath) {
        this.md5Hash = md5Hash;
        String[] filePathAndName = geFilePathAndFileName(fileNameWithPath);
        String filePath = filePathAndName[FILE_PATH_INDEX];
        String fileName = filePathAndName[FILE_NAME_INDEX];
        this.filePath = filePath;
        this.fileName = fileName;
    }

    public static FilePathChecksumTriple getInstance(
            String doubleSpaceSeparatedMd5HashAndFileNameWithPath) {
        String[] md5HashAndFileNameWithPath = splitSpaceSeparatedMd5HashAndFileNameWithPath(doubleSpaceSeparatedMd5HashAndFileNameWithPath);
        String md5Hash = md5HashAndFileNameWithPath[MD5_HASH_INDEX];
        String fileNameWithPath = md5HashAndFileNameWithPath[FILE_NAME_AND_PATH_INDEX];
        String[] filePathAndName = geFilePathAndFileName(fileNameWithPath);
        String filePath = filePathAndName[FILE_PATH_INDEX];
        String fileName = filePathAndName[FILE_NAME_INDEX];
        return new FilePathChecksumTriple(md5Hash, filePath, fileName);
    }

    public String getMd5Hash() {
        return md5Hash;
    }

    public String getFilePath() {
        return filePath;
    }

    public String getFileName() {
        return fileName;
    }

    public String getFilePathAndName() {
        return filePath + fileName;
    }

    @Override
    public String toString() {
        return "FilePathChecksumTriple [md5Hash=" + md5Hash + ", filePath="
                + filePath + ", fileName=" + fileName + "]";
    }

    @Override
    public int hashCode() {
        final int prime = 31;
        int result = 1;
        result = prime * result
                + ((fileName == null) ? 0 : fileName.hashCode());
        result = prime * result
                + ((filePath == null) ? 0 : filePath.hashCode());
        result = prime * result + ((md5Hash == null) ? 0 : md5Hash.hashCode());
        return result;
    }

    @Override
    public boolean equals(Object obj) {
        if (this == obj)
            return true;
        if (obj == null)
            return false;
        if (getClass() != obj.getClass())
            return false;
        FilePathChecksumTriple other = (FilePathChecksumTriple) obj;
        if (fileName == null) {
            if (other.fileName != null)
                return false;
        } else if (!fileName.equals(other.fileName))
            return false;
        if (filePath == null) {
            if (other.filePath != null)
                return false;
        } else if (!filePath.equals(other.filePath))
            return false;
        if (md5Hash == null) {
            if (other.md5Hash != null)
                return false;
        } else if (!md5Hash.equals(other.md5Hash))
            return false;
        return true;
    }

    protected static String[] splitSpaceSeparatedMd5HashAndFileNameWithPath(
            String spaceSeparatedMd5HashAndFileNameWithPath) {
        if (spaceSeparatedMd5HashAndFileNameWithPath == null) {
            throw new IllegalArgumentException("Input must not be null");
        }
        String[] md5HashAndFileNameWithPath = spaceSeparatedMd5HashAndFileNameWithPath
                .split(DOUBLE_SPACE);
        if (md5HashAndFileNameWithPath.length != 2) {
            throw new IllegalArgumentException(
                    "Unable to parse md5hash and filepath/name from >>"
                            + spaceSeparatedMd5HashAndFileNameWithPath + "<<");
        }
        return md5HashAndFileNameWithPath;
    }

    protected static String[] geFilePathAndFileName(String fileNameWithPath) {
        String[] filePathAndName = new String[2];
        int lastForwardSlashIndex = fileNameWithPath.lastIndexOf(FORWARD_SLASH);
        if (wasLastForwardSlashFound(lastForwardSlashIndex)) {
            int beginIndexInclusive = 0;
            int endIndexExclusive = lastForwardSlashIndex + 1;
            filePathAndName[FILE_PATH_INDEX] = fileNameWithPath.substring(
                    beginIndexInclusive, endIndexExclusive);
            if (lastForwardSlashIndex < fileNameWithPath.length()) {
                beginIndexInclusive = lastForwardSlashIndex + 1;
                endIndexExclusive = fileNameWithPath.length();
                filePathAndName[FILE_NAME_INDEX] = fileNameWithPath.substring(
                        beginIndexInclusive, endIndexExclusive);
            }
        } else {
            filePathAndName[FILE_NAME_INDEX] = fileNameWithPath;
            filePathAndName[FILE_PATH_INDEX] = EMPTY_STRING;
        }
        return filePathAndName;
    }

    private static boolean wasLastForwardSlashFound(int lastForwardSlash) {
        return lastForwardSlash != -1;
    }

}

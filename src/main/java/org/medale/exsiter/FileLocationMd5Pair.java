package org.medale.exsiter;

/**
 * Assumes Unix paths, i.e. directories separated by /. Stores md5hash for a
 * given file at a file path (generated by find piped to md5sum command).<br>
 * Command: find . -type f | xargs md5sum.<br>
 * Note: Output contains 128-bit checksum followed by double space followed by
 * path with filename.<br>
 * Examples:
 * <ol>
 * <li>7455657be214e67f36009154d3653e1b ./.bash_profile</li>
 * <li>56a329926a92460b9b6ac1377f610e48 ./web/newsletter/grip-it.jpg</li>
 * </ol>
 */
public class FileLocationMd5Pair {

    protected static final int MD5_HASH_INDEX = 0;
    protected static final int FILE_LOCATION_INDEX = 1;
    protected static final String DOUBLE_SPACE = "  ";

    protected static final String EMPTY_STRING = "";

    private String md5Hash;
    private final String fileLocation;

    public FileLocationMd5Pair(final String md5Hash, final String fileLocation) {
        this.md5Hash = md5Hash;
        this.fileLocation = fileLocation;
    }

    public static FileLocationMd5Pair getInstance(
            final String doubleSpaceSeparatedMd5HashAndFileLocation) {
        final String[] md5HashAndFileLocation = splitSpaceSeparatedMd5HashAndFileLocation(doubleSpaceSeparatedMd5HashAndFileLocation);
        final String md5Hash = md5HashAndFileLocation[MD5_HASH_INDEX];
        final String fileLocation = md5HashAndFileLocation[FILE_LOCATION_INDEX];
        return new FileLocationMd5Pair(md5Hash, fileLocation);
    }

    public String getMd5Hash() {
        return this.md5Hash;
    }

    /**
     * Used for testing purposes only
     * 
     * @param newMd5Hash
     */
    void setMd5Hash(final String newMd5Hash) {
        this.md5Hash = newMd5Hash;
    }

    public String getFileLocation() {
        return this.fileLocation;
    }

    protected static String[] splitSpaceSeparatedMd5HashAndFileLocation(
            final String spaceSeparatedMd5HashAndFileLocation) {
        if (spaceSeparatedMd5HashAndFileLocation == null) {
            throw new IllegalArgumentException("Input must not be null");
        }
        final String[] md5HashAndFileLocation = spaceSeparatedMd5HashAndFileLocation
                .split(DOUBLE_SPACE);
        if (md5HashAndFileLocation.length != 2) {
            throw new IllegalArgumentException(
                    "Unable to parse md5hash and filepath/name from >>"
                            + spaceSeparatedMd5HashAndFileLocation + "<<");
        }
        return md5HashAndFileLocation;
    }

    @Override
    public int hashCode() {
        final int prime = 31;
        int result = 1;
        result = (prime * result)
                + ((this.fileLocation == null) ? 0 : this.fileLocation
                        .hashCode());
        result = (prime * result)
                + ((this.md5Hash == null) ? 0 : this.md5Hash.hashCode());
        return result;
    }

    @Override
    public boolean equals(final Object obj) {
        if (this == obj) {
            return true;
        }
        if (obj == null) {
            return false;
        }
        if (getClass() != obj.getClass()) {
            return false;
        }
        final FileLocationMd5Pair other = (FileLocationMd5Pair) obj;
        if (this.fileLocation == null) {
            if (other.fileLocation != null) {
                return false;
            }
        } else if (!this.fileLocation.equals(other.fileLocation)) {
            return false;
        }
        if (this.md5Hash == null) {
            if (other.md5Hash != null) {
                return false;
            }
        } else if (!this.md5Hash.equals(other.md5Hash)) {
            return false;
        }
        return true;
    }

    @Override
    public String toString() {
        return "FileLocationMd5Pair [md5Hash=" + this.md5Hash
                + ", fileLocation=" + this.fileLocation + "]";
    }

}
